---
title: "Board Games and Individual Ratings"
author: "Crystal Zhang, Lauren Grove, Nate Ren"
date: "5-1-24"
format: pdf
---

# Set Up

```{r import}

pacman::p_load(tidyverse, stringr, RColorBrewer, ggplot2)

```

# Import Data set

We are using the board games data from tidytuesday in 2019. The data comes from the Board Games Geek database which allows users to rates board games. The data spans from 1950 to 2016 with games that have at least 50 ratings.

```{r}

board_games_data_raw <- read.csv("./board_games.csv")

head(board_games_data_raw)

```

# Data Exploration

First we need to have an overview of the data set as a basis of further analysis.

## Data Structure

```{r}

str(board_games_data_raw)

```

There are a total of 10523 observations, each representing a different board game. The dataset consists of 22 variables, which includes the types integer, string, and numerical. The integer variables are:game_id, max_players, max_playtime, min_age, min_players, min_playtime, playing_time, year_published, and users_rated. The character variables are: description, image, name, thumbnail, artist, category, compilation,â€˜designer, expansion, family, mechanic, and publisher. The only numerical variable is average_rating. More information on variables can be seen in the Variable List

## Data Summary

```{r}

summary(board_games_data_raw)

```

This is a basic summary of the data set. The distribution of integer and numerical variables, such as max_playtime and min_players are demonstrated with the 5-number summary and the mean. For character variables, only length (which is the same as the number of observations), class, and mode (both of these show the data type) are present.

Although it is an numerical variable, `game_id` does not provide any relevant statistical information, as it is only used for identifying a game.

According to this summary, values for `max_players` tend to be under 10 with a median of 4 and a mean of 5.657, which are realistic numbers for a game, and an outlying max of 999.

Meanwhile `max_playtime` have a median of 45, a mean of 91.34, and and on outlier max of 60000 (the possible reason why the mean is so much higher than the median).

For `min_age`, the median is 10 and the mean is 9.715. Curiously, the max is 42, which could be a potential error.

`min_players` have a median of 2, a mean of 2.071, and a max of 9.

`min_playtime` have a median of 45 and a mean of 80.88. It also has a max of 60000, which again is likely an error as it is not a realistic minimum playtime.

`playing_time` have a median of 45, a mean of 91.34, and a max of 60000.

`year_plushed` have a median of 2007, a mean of 2003, and a max of 2016. This means that the most recent game in the data set is published in 2016.

`average_rating` have a median of 6.393 and a mean of 6.371.

`users_rated` have a median of 176 and a mean of 870. It also has asignificantly large max of 67655.

# Data Dictionary

This is the data dictionary for this data set

## Variable List

-   game_id = unique board game ID Number

    -   Data Type = Integer

-   description = short description of the game

    -   Data Type = String

-   max_players = the largest amount of players that can play the board game at a certain time

    -   Data Type - Integer

-   max_playtime = the longest estimated amount of time that it will take for people to finish playing the game. This is written in minutes

    -   Data Type = Integer

-   min_age = the minimum age a person needs to be in order to play the board game

    -   Data Type = Integer

-   min_players = the minimum amount of people that can play the board game at a certain time

    -   Data Type = Integer

-   min_playtime = the shortest estimated amount of time that it will take for people to finish playing the game. This is written in minutes.

    -   Data Type = Integer

-   name = the name of the board game

    -   Data Type = String

-   playing_time = the estimated average amount of time that it will take for people to finish playing the game. This is written in minutes

    -   Data Type = Integer

-   year_published = the year that the game was published

    -   Data Type = Integer

-   category = this is a string that says what categories each board game belongs to. If a board game has multiple categories all of them will be written down and will be separated by commas

    -   Data Type = String

-   compilation = if the game is part of a multi-game compilation is lists what compilation it is apart of

    -   Data Type = String

-   designer = this is the name of the person or people that designed the game. If there are multiple people that designed a game their names are split by commas in between each name

    -   Data Type = String

-   expansion = if the game has an expansion pack this variable has the name of the expansion pack. If the game has multiple expansion packs each expansion pack is split by commas.

    -   Data Type = String

-   mechanic = this explains how the game is played and what the game uses to work. If a game uses multiple elements to run the elements are split by commas

    -   Data Type = String

-   publisher = this is the company or people that published the game. If a game has multiple publishers then the publishers are split by commas

    -   Data Type = String

-   average_rating = this is the average rating of the game on Board Game Geek. The rating system runs on a scale from 1 to 10

    -   Data Type = Double

-   users_rated = This is the number of user that rated the game on Board Game Geek.

    -   Data Type = Integer

# Research Questions

The research questions we intend to answer are **for each decade what primary game category had the highest user rating** and **between `average_playtime`, number of users rated, and max player which has the greatest correlation with average rating**. To answer the first question, we will assume that the first category listed in `category` is the primary game category. We will create a new variable called `primary_category` that stores the split category column. We use `lubridate` change `year_published` into datetime object with January 1st as default date. Then we'll use `floor_date()` to find what decade each game was released in.

# Cleaning Methods

To answer the questions of our research, we need to perform the following cleaning tasks:

1.  Remove `image` and `thumbnail` columns using `select()`

2.  Recode `compilation` and `expansion` values to yes or no

3.  Recode `max_players` of `999` to `NA`

4.  Identify how many `NA` values are in each column

5.  Split `category` data by commas to get primary category by/using str_split

6.  Change `primary_category` variable from character to a factor

7.  Use `lubridate` to change `year` variable to a date

# Data Cleaning

```{r}
# remove `image` and `thumbnail` columns
board_games <- board_games_data_raw |> 
  select(-c("image", "thumbnail"))

#Recode `compilation` and `expansion` values to yes or no
for (i in 1:length(board_games$compilation)) {
  if (is.na(board_games$compilation[i])){
    board_games$compilation[i] <- "no"}
  else {
board_games$compilation[i] <- "yes"}
}
for (i in 1:length(board_games$expansion)) {
  if (is.na(board_games$expansion[i])){
    board_games$expansion[i] <- "no"}
  else {
    board_games$expansion[i] <- "yes" }
}

# replace `max_players` values of `999` with `NA`
board_games <- board_games |> 
  mutate(max_players = replace(max_players, max_players == 999, NA))

# Identify how many `NA` values are in each column 
ShowNA <- map_df(board_games, ~ tibble(columns = names(.), na_count = sum(is.na(.))), .id = "variables/column name")

#make a new column called decade_published to store date time objects
board_games$decade_published = c(as.Date(as.character(board_games_data_raw$year_published), format = "%Y"))
board_games <- board_games%>%
  mutate(decade_published = floor_date(decade_published, years(10)))

#use floor_date to set to decade

#make a new category to hold the primary category
board_games$primary_category = c(board_games$category)

#under assumption that first category listed is the primary category
board_games <- board_games%>%
  mutate(primary_category = str_split(category, ",") %>% 
           #use split to make a list for each column of all the categories
           map_chr(~ trimws(.x[1])))
          # iterate over each element of the list column (.x) and extract the first element ([1])
          #trimws is used to remove any white space
#turn primary_characor column into a factor
primary_charactor_factor <- as.factor(board_games$primary_category)
print(unique(primary_charactor_factor))
```

# Data Visualization

## Research Question 1

**for each decade what primary game category had the highest user rating**

```{r fig.height = 10}
# Summarize ratings by decade_published and primary_category
ratings_by_category <- board_games %>%
  group_by(decade_published, primary_category) %>%
  summarise(avg_category_rating = mean(average_rating, na.rm = TRUE), .groups = "drop") %>%
  ungroup()

# Create a data frame with unique decade_published dates
unique_decades <- data.frame(date = as.POSIXct(unique(ratings_by_category$decade_published)))

# Function to extract decade from a date
get_decade <- function(date) {
  year <- as.integer(format(date, "%Y"))
  decade_start <- year - (year %% 10)
  return(as.factor(sprintf("%ds", decade_start)))
}

# Apply the function to create a 'decade' factor column
unique_decades$decade <- sapply(unique_decades$date, get_decade)

# Loop through unique decades and create plots
for (decade in unique(unique_decades$decade)) {
  # Filter ratings data by the current decade
  decade_ratings <- ratings_by_category[ratings_by_category$decade_published %in% unique_decades$date[unique_decades$decade == decade], ]
  
  # Create a larger plot with increased dodging width
  p <- ggplot(decade_ratings, aes(x = primary_category, y = avg_category_rating)) +
    geom_bar(stat = "identity", fill = "purple", color = "black", position = position_dodge(width = 1.0)) +
    labs(title = sprintf("Average Category Rating by Decade: %s", as.character(decade)),
         x = "Primary Category", y = "Average Category Rating") +
    theme_minimal() +
    coord_flip()+# Flip plot coordinates to horizontal bars
    geom_text(aes(label = ifelse(avg_category_rating == avg_category_rating, sprintf("%.2f", avg_category_rating), "")),
              vjust = -0.5, size = 3, color = "black") # Add text labels for max ratings
  # Print the plot
  print(p)
}
```

## Research Question 2

# Conclusion
